name: Local Kind CI/CD Pipeline

on:
  push:
    branches:
      - master
    paths:
      - 'internal/**'
      - 'cmd/**'
      - 'deploy/**'
      - '.github/workflows/cicd-pipeline.yaml'

# Global environment variables
env:
  KIND_CLUSTER_NAME: dev-cluster
  # You can override these proxy settings in your repository's secrets if needed
  HTTP_PROXY_URL: http://host.docker.internal:7897
  HTTPS_PROXY_URL: http://host.docker.internal:7897

jobs:
  ci-check:
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for accurate diff
          clean: true

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23.3' # Using version from GEMINI.md
          cache: false # Disable caching to prevent conflicts on self-hosted runner

      - name: Run Go Tests
        run: go test -v ./...

      - name: Install and Run Go Linter
        run: |
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
          $(go env GOPATH)/bin/golangci-lint run ./...

  identify-changes:
    runs-on: self-hosted
    outputs: 
      services: ${{ steps.set-matrix.outputs.services }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for git diff

      - name: Install jq if not present
        run: |
          if ! command -v jq &> /dev/null
          then
              echo "jq could not be found, installing it..."
              if [[ "$(uname)" == "Darwin" ]]; then
                  echo "macOS detected, using Homebrew..."
                  brew install jq
              elif [[ "$(uname)" == "Linux" ]]; then
                  echo "Linux detected, using apt-get..."
                  sudo apt-get update
                  sudo apt-get install -y jq
              else
                  echo "Unsupported OS for jq installation: $(uname)"
                  exit 1
              fi
          else
              echo "jq is already installed."
          fi

      - name: Identify changed services
        id: set-matrix
        run: |
          # Get a list of changed files since the last commit on the branch
          changed_files=$(git diff --name-only HEAD^ HEAD)
          
          # Check if common directory or the workflow file was changed
          if echo "$changed_files" | grep -q "internal/common/" || echo "$changed_files" | grep -q ".github/workflows/cicd-pipeline.yaml"; then
            # If common changed, build all services by listing directories in cmd/
            services=$(ls -d cmd/*/ | xargs -n 1 basename | jq -R . | jq -sc .)
          else
            # Otherwise, get the unique service names from the changed paths
            # e.g., internal/user/app.go -> user_service OR cmd/user_service/main.go -> user_service OR deploy/user_service/Dockerfile -> user_service
            services=$(echo "$changed_files" | grep -E '^(internal|cmd|deploy)/' | sed -n -e 's|internal/\([^/]*\)/.*|\1_service|p' -e 's|cmd/\([^/]*\)/.*|\1|p' -e 's|deploy/\([^/]*\)/.*|\1|p' | sort -u | jq -R . | jq -sc .)
          fi
          
          echo "Services to rebuild: $services"
          echo "services=$services" >> $GITHUB_OUTPUT

  build-and-deploy:
    needs: [identify-changes, ci-check]
    if: needs.identify-changes.outputs.services != '[]'
    # This job must run on a self-hosted runner with Docker, Kind, and Kubectl installed
    runs-on: self-hosted
    strategy:
      matrix:
        service: ${{ fromJson(needs.identify-changes.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build Docker image
        run: |
          # Convert service name from 'user_service' to 'user-service' for the image tag
          IMAGE_TAG_BASE=$(echo ${{ matrix.service }} | sed 's/_/-/g')
          echo "Building ${IMAGE_TAG_BASE}:latest"...
          
          docker build -t ${IMAGE_TAG_BASE}:latest \
            --build-arg HTTP_PROXY=${{ env.HTTP_PROXY_URL }} \
            --build-arg HTTPS_PROXY=${{ env.HTTPS_PROXY_URL }} \
            -f deploy/${{ matrix.service }}/Dockerfile .

      - name: Load image into Kind
        run: |
          IMAGE_TAG_BASE=$(echo ${{ matrix.service }} | sed 's/_/-/g')
          echo "Loading ${IMAGE_TAG_BASE}:latest into Kind cluster '${{ env.KIND_CLUSTER_NAME }}'"...
          kind load docker-image ${IMAGE_TAG_BASE}:latest --name ${{ env.KIND_CLUSTER_NAME }}

      - name: Deploy to Kubernetes
        run: |
          # Convert service name for manifest path and resource name
          K8S_RESOURCE_NAME=$(echo ${{ matrix.service }} | sed 's/_/-/g')
          K8S_MANIFEST_PATH="deploy/${{ matrix.service }}/kubernetes/${K8S_RESOURCE_NAME}.yaml"
          
          echo "Applying manifest ${K8S_MANIFEST_PATH}"...
          kubectl apply -f $K8S_MANIFEST_PATH
          
          echo "Restarting deployment 'deployment/${K8S_RESOURCE_NAME}' to apply changes..."
          kubectl rollout restart deployment/${K8S_RESOURCE_NAME}
          
          echo "Waiting for deployment to complete..."
          kubectl rollout status deployment/${K8S_RESOURCE_NAME} --timeout=60s